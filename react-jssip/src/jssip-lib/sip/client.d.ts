import { SipUserAgent } from "./userAgent";
import { AnswerOptions, CallOptions, DTFMOptions, JsSIPEventMap, ReferOptions, RTCSession, RTCSessionEvent, SipConfiguration, SipEventManager, TerminateOptions } from "./types";
import { SipState } from "../core/types";
import { EventTargetEmitter } from "../core/eventEmitter";
import { SipErrorHandler, SipErrorFormatter } from "../core/sipErrorHandler";
import { SipStateStore } from "../core/sipStateStore";
type SipClientOptions = {
    errorMessages?: Record<string, string>;
    formatError?: SipErrorFormatter;
    errorHandler?: SipErrorHandler;
    debug?: boolean | string;
};
export declare class SipClient extends EventTargetEmitter<JsSIPEventMap> {
    readonly userAgent: SipUserAgent;
    readonly stateStore: SipStateStore;
    private readonly uaHandlers;
    private readonly uaHandlerKeys;
    private sessionHandlers;
    private readonly errorHandler;
    private debugPattern?;
    private sessionManager;
    private lifecycle;
    get state(): SipState;
    constructor(options?: SipClientOptions);
    connect(uri: string, password: string, config: SipConfiguration): void;
    registerUA(): void;
    disconnect(): void;
    call(target: string, callOptions?: CallOptions): void;
    answer(options?: AnswerOptions): void;
    hangup(options?: TerminateOptions): void;
    mute(): void;
    unmute(): void;
    hold(): void;
    unhold(): void;
    sendDTMF(tones: string | number, options?: DTFMOptions): void;
    transfer(target: string | RTCSession, options?: ReferOptions): void;
    attendedTransfer(otherSession: RTCSession): void;
    onChange(fn: (s: SipState) => void): () => void;
    private attachUAHandlers;
    setDebug(debug?: boolean | string): void;
    private attachSessionHandlers;
    private detachSessionHandlers;
    private detachUAHandlers;
    private cleanupSession;
    private cleanupAllSessions;
    private createSessionHandlersFor;
    protected onNewRTCSession(e: RTCSessionEvent): void;
    protected onSessionFailed(error?: string, event?: RTCSessionEvent): void;
    private emitError;
    private resolveSessionId;
    answerSession(sessionIdOrOptions?: string | AnswerOptions, options?: AnswerOptions): boolean;
    hangupSession(sessionIdOrOptions?: string | TerminateOptions, options?: TerminateOptions): boolean;
    muteSession(sessionId?: string): boolean;
    unmuteSession(sessionId?: string): boolean;
    holdSession(sessionId?: string): boolean;
    unholdSession(sessionId?: string): boolean;
    sendDTMFSession(tones: string | number, options?: DTFMOptions, sessionId?: string): boolean;
    transferSession(target: string | RTCSession, options?: ReferOptions, sessionId?: string): boolean;
    attendedTransferSession(otherSession: RTCSession, sessionId?: string): boolean;
    setSessionMedia(sessionId: string, stream: MediaStream): void;
    switchCameraSession(sessionId: string, track: MediaStreamTrack): boolean;
    startScreenShareSession(sessionId: string, getDisplayMedia: () => Promise<MediaStream>): Promise<boolean>;
    enableVideoSession(sessionId: string): boolean;
    disableVideoSession(sessionId: string): boolean;
    getSession(sessionId: string): RTCSession | null;
    getSessionIds(): string[];
    getSessions(): {
        id: string;
        session: RTCSession;
    }[];
}
export declare function createSipClientInstance(options?: SipClientOptions): SipClient;
export declare function createSipEventManager(client: SipClient): SipEventManager;
export {};
