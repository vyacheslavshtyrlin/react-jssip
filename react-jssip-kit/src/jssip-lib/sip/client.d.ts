import { SipUserAgent } from "./userAgent";
import { AnswerOptions, CallOptions, DTFMOptions, JsSIPEventMap, ReferOptions, RTCSession, RTCSessionEvent, SipConfiguration, SipEventManager, TerminateOptions } from "./types";
import { SipState } from "../core/types";
import { EventTargetEmitter } from "../core/eventEmitter";
import { SipErrorHandler, SipErrorFormatter } from "../core/sipErrorHandler";
import { SipStateStore } from "../core/sipStateStore";
type SipClientOptions = {
    errorMessages?: Record<string, string>;
    formatError?: SipErrorFormatter;
    errorHandler?: SipErrorHandler;
    debug?: boolean | string;
};
export declare class SipClient extends EventTargetEmitter<JsSIPEventMap> {
    readonly userAgent: SipUserAgent;
    readonly stateStore: SipStateStore;
    private readonly uaHandlers;
    private readonly uaHandlerKeys;
    private sessionHandlers;
    private readonly errorHandler;
    private debugPattern?;
    private sessionManager;
    private lifecycle;
    get state(): SipState;
    constructor(options?: SipClientOptions);
    connect(uri: string, password: string, config: SipConfiguration): void;
    registerUA(): void;
    disconnect(): void;
    call(target: string, callOptions?: CallOptions): void;
    answer(sessionId: string, options?: AnswerOptions): boolean;
    hangup(sessionId: string, options?: TerminateOptions): boolean;
    toggleMute(sessionId: string): boolean;
    toggleHold(sessionId: string): boolean;
    sendDTMF(sessionId: string, tones: string | number, options?: DTFMOptions): void;
    transfer(sessionId: string, target: string | RTCSession, options?: ReferOptions): void;
    attendedTransfer(sessionId: string, otherSession: RTCSession): void;
    onChange(fn: (s: SipState) => void): () => void;
    private attachUAHandlers;
    setDebug(debug?: boolean | string): void;
    private attachSessionHandlers;
    private detachSessionHandlers;
    private detachUAHandlers;
    private cleanupSession;
    private cleanupAllSessions;
    private createSessionHandlersFor;
    protected onNewRTCSession(e: RTCSessionEvent): void;
    protected onSessionFailed(error?: string, event?: RTCSessionEvent): void;
    private emitError;
    private resolveSessionId;
    answerSession(sessionId: string, options?: AnswerOptions): boolean;
    hangupSession(sessionId: string, options?: TerminateOptions): boolean;
    toggleMuteSession(sessionId?: string): boolean;
    toggleHoldSession(sessionId?: string): boolean;
    sendDTMFSession(sessionId: string, tones: string | number, options?: DTFMOptions): boolean;
    transferSession(sessionId: string, target: string | RTCSession, options?: ReferOptions): boolean;
    attendedTransferSession(sessionId: string, otherSession: RTCSession): boolean;
    setSessionMedia(sessionId: string, stream: MediaStream): void;
    switchCameraSession(sessionId: string, track: MediaStreamTrack): boolean;
    enableVideoSession(sessionId: string): boolean;
    disableVideoSession(sessionId: string): boolean;
    getSession(sessionId: string): RTCSession | null;
    getSessionIds(): string[];
    getSessions(): {
        id: string;
        session: RTCSession;
    }[];
}
export declare function createSipClientInstance(options?: SipClientOptions): SipClient;
export declare function createSipEventManager(client: SipClient): SipEventManager;
export {};
